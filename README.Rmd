---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# lordecks 

<!-- badges: start -->
<!-- badges: end -->

The package can be used to encode/decode Legends of Runeterra decks to/from simple strings.
Such codes are e.g. generated by the game for imports and exports and also how decks are
specified in the game API. Any analysis of matchdata therefore requires the ability to 
parse deck codes into actual deck lists.

This is an R implementation following https://github.com/RiotGames/LoRDeckCodes .

## Installation

You can install *lordecks* from github via:

``` r
remotes::install_github("https://github.com/pholzmgit/lordecks")
```

## Usage

### Parsing deck codes

The library provides a function that parses deck codes into interpretable deck lists. For the output format, 2 options are available

* minimalist character vector ("\{count\}:\{cardcode\}", representing the testdata format of the original C# library)
* dataframe with some additional columns, ready for further analysis in R (default)

```{r}
library(lordecks)

deck_code <- "CEDACAIFDUAQEBAIAECAIBICAECDGNACAMCQIBQDAMCAKDISAIAQCBBWAIAQKEZPAIAQGBIMAMAQKAIZEE"

simple_decklist <- get_decklist_from_code(deck_code, format = "simple")

simple_decklist
```


```{r}
df_decklist <- get_decklist_from_code(deck_code)

df_decklist
```


### Generate deck codes

For both deck formats, functions for the reverse action are provided

```{r}
get_code_from_decklist(simple_decklist)
```

```{r}
# a dataframe with only 'cardcode' and 'count' columns is sufficient, all other columns are ignored
get_code_from_decklist_df(df_decklist)
```

## Note on deck code versions

The deck codes start with 4 bit for format and 4 bit for version. So far this only indicates which regions are available - too old versions of the decoder have no information on factions released more recently. The C# library always generates codes with the latest version, but the actual game does not. 

Instead, the lowest possible version based on the factions in the deck is encoded. **In this aspect, the library follows the implementation of the game**. While this results in slightly different deck codes, the resulting decklists are identical.

```{r}
#example code list provided from the test data set
code <- "CMAQSAIFBMHREHRAFEVCWMABAYAQKAIUDURSYLIBAEAQKGQ"

#manually import and re-export in the game (Patch 2.10)
code_game <- "CEAQSAIFBMHREHRAFEVCWMABAYAQKAIUDURSYLIBAEAQKGQ"

code_lordecks <- get_code_from_decklist_df(get_decklist_from_code(code))
code_lordecks
```

```{r}
identical(code, code_lordecks)
identical(code_game, code_lordecks)
```

```{r}
identical(
  get_decklist_from_code(code),
  get_decklist_from_code(code_lordecks)
)
```










